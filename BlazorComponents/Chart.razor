@inject IJSRuntime JSRuntime
@implements IDisposable

<div @ref="_element" @attributes="Attributes"></div>

@code {
    [Parameter]public string RenderScript { get; set; } = "__components.chart.render";
    [Parameter]public bool IsLoading { get; set; }
    [Parameter]public object Options { get; set; } = new { };
    [Parameter(CaptureUnmatchedValues = true)]public Dictionary<string, object> Attributes { get; set; } = new Dictionary<string, object>();

    ElementReference _element;
    object? _oldOptions;
    bool? _oldIsLoading;

    public Task RenderAsync(object options)
    {
        if (ComponentContext.IsConnected)
        {
            return JSRuntime.InvokeAsync<object>(RenderScript, _element, options);
        }
        else
        {
            return Task.CompletedTask;
        }
    }

    public override async Task SetParametersAsync(ParameterView parameters)
    {
        _oldOptions = Options;
        _oldIsLoading = IsLoading;

        await base.SetParametersAsync(parameters);

        if (ComponentContext.IsConnected && _oldIsLoading != IsLoading)
        {
            _ = JSRuntime.InvokeAsync<object>("__components.chart.showLoading", _element, IsLoading);
        }
    }

    protected override bool ShouldRender()
    {
        return _oldOptions != Options;
    }

    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender && ShouldRender())
        {
            return JSRuntime.InvokeAsync<object>("__components.chart.render", _element, Options);
        }
        else
        {
            return Task.CompletedTask;
        }
    }

    public void Dispose()
    {
        if (ComponentContext.IsConnected)
        {
            _ = JSRuntime.InvokeAsync<object>("__components.chart.destroy", _element);
        }
    }
}
